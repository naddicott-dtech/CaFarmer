Develop a browser-based (HTML/JavaScript/CSS) simulation game inspired by the "Civilization" series. The game simulates a procedurally generated California family farm where players manage diverse crops, water, soil, and economics under evolving climate conditions. The simulation uses daily ticks (with variable pace for “plant/harvest/crisis” versus “hurry up and wait” periods), randomly generated events (e.g., droughts, floods, wildfires, tariffs) and tech trees that unlock new adaptive strategies. The UI includes a grid-based view of the farm (with color-coded metrics such as yield), a HUD displaying bank balance, debt, farm value, farm health, and years played, and supports granular zone decisions (even per square). The design is meant to entertain and educate by highlighting that adaptive, smart management is key for survival under climate change.

1. Functional Requirements
Simulation Engine:

Runs in daily ticks; supports variable time scales.
Updates state variables (water balance, soil nutrients, crop growth via GDD, yield, economic factors) using real-world formulas.
Implements models for water balance, nutrient cycling, soil erosion (e.g. USLE), and yield response (FAO water-yield relation).
Random Event Generator:

Produces plausible, probabilistic events (drought, flood, wildfire, tariff changes) based on regional data.
Alters simulation parameters (e.g., reducing water availability, triggering yield loss).
Tech Tree Module:

Manages research/upgrades (e.g., no-till, AI irrigation, drone-based precision).
Unlocks new gameplay options when prerequisites are met.
Applies cost/efficiency benefits to simulation variables.
Farm Grid View:

Displays the farm as a grid (each cell with attributes like yield, soil quality, water status).
Supports zone or square-level decisions (e.g., crop type mix, targeted upgrades).
Allows color-coded overlays (switchable views such as yield or nutrient status).
HUD Module:

Displays metrics: bank balance, debt, farm value, farm health, years played.
Updates dynamically with simulation state changes.
User Interface & Integration:

Uses HTML/CSS for layout and styling.
JavaScript for simulation logic, DOM interactions, and event handling.
Minimal in-game tooltips; advisors provided externally (players can copy/paste queries).
Data Persistence:

Optionally use local storage for game state saving.
2. System Architecture & Modules
Module 1: Simulation Engine

Responsibilities:
Calculate daily water balance:
M[t+1] = M[t] + I[t] + R[t] - (Kc × ET₀[t]) - D[t]
Accumulate Growing Degree Days (GDD) and update crop stages.
Update soil nutrient levels using a mass balance approach.
Compute yield reduction via:
1 - (Y / Y_max) = Ky × (1 - (ET_actual / ET_full))
Tests:
Verify water balance update given sample inputs.
Confirm GDD accumulation transitions crop stages correctly.
Check nutrient cycling (inputs vs. losses) over simulated days.
Validate yield calculation under simulated water stress conditions.
Module 2: Random Event Generator

Responsibilities:
Generate events based on region-specific probabilities.
Modify simulation variables (e.g., drop water levels for drought, spike water costs for flood).
Tests:
Simulate multiple days to verify event frequency aligns with set probabilities.
Ensure that events correctly adjust the simulation state (e.g., triggering a 20% yield loss on drought events).
Module 3: Tech Tree Manager

Responsibilities:
Maintain tech tree nodes with prerequisites, costs, and benefits.
Unlock upgrades that adjust simulation parameters (e.g., reduce irrigation water loss).
Tests:
Test prerequisite checks and proper unlocking of tech nodes.
Verify that applied tech upgrades modify simulation variables (e.g., lower labor costs or water usage) as specified.
Module 4: Farm Grid & Zone Management

Responsibilities:
Render a grid (using canvas or an HTML table) representing the farm.
Allow players to view different metrics (yield, soil quality, water status) via color overlays.
Support cell-level interactions for crop zoning decisions.
Tests:
Check grid renders correctly with the correct number of cells.
Verify that clicking on a cell brings up selection options.
Confirm that color overlays correctly represent underlying simulation data.
Module 5: HUD & UI Integration

Responsibilities:
Display key metrics (bank balance, debt, etc.) that update each tick.
Integrate with simulation engine and farm grid.
Tests:
Ensure HUD metrics update in real time as simulation variables change.
Validate that UI events (e.g., zone decision changes) propagate to the simulation state.
Module 6: Data Persistence & Save/Load

Responsibilities:
Save game state (simulation variables, tech tree progress, farm grid layout) to local storage.
Load saved state accurately.
Tests:
Save a game state and verify all variables are restored correctly on load.
3. Development Phases & Progressive Implementation
Phase 1: Core Simulation Engine

Implement daily tick loop, water balance, GDD, and basic yield calculations.
Write tests for simulation formulas.
Phase 2: HUD & Farm Grid UI

Develop basic UI with HTML/CSS.
Render a grid view and HUD; integrate with simulation engine.
Write UI integration tests.
Phase 3: Random Events & Tech Tree

Implement random event generator with event triggers.
Build the tech tree module with upgrade effects.
Write tests ensuring events and tech tree unlocks affect simulation state correctly.
Phase 4: Integration & Polish

Combine all modules; ensure smooth transitions between “slow” simulation phases and “fast” waiting periods.
Test game state persistence, responsiveness, and overall user experience.
4. Testing & Quality Assurance
Unit Testing:

Use a JavaScript testing framework (e.g., Jasmine or Mocha) for each module.
Write unit tests for simulation formulas, event generation probabilities, UI response, and tech tree logic.
Integration Testing:

Simulate full game ticks and verify that modules interact as expected (e.g., a drought event should trigger water stress in the simulation engine and reflect on the HUD).
User Acceptance Testing:

Ensure that the game runs in standard web browsers.
Validate that gameplay is balanced (random starting locations, fair progression, clear metrics).
5. Deliverables & Constraints
Code Artifacts:

Well-organized HTML, CSS, and JavaScript files.
Clear inline comments and documentation.
Modular design to allow progressive development (each module testable in isolation).
Performance:

Optimize simulation tick speed (support both detailed daily ticks and fast-forward modes).
Ensure responsive UI updates, especially for grid view rendering.
Documentation:

Provide this TDD alongside the research information as a comprehensive spec.
Keep explanations concise to conserve context tokens, using clear pseudocode where necessary.
